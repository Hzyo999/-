<font size=8>毕业设计进度
========

<font size=6>20230309
-------

<font size=5 face="黑体">本周阅读了FEMU中写入操作部分和部分代码需改。对于FEMU写操作部分，FEMU中采用NVME协议结合QEMU中的内存管理方式来实现I/O操作。我结合NVME 1.3协议和QEMU的相关文档进行项目中相关代码的阅读。然后简单构思了一下需要实现的部分和需要注意的点：写入缓冲区需要设置在NVME写操作从内存中获取数据并进行分页之后，同时写入缓冲区的设置是页对齐且分配了页号（即把写入缓冲区当成NAND Flash），这样从缓冲区进行读取就只需要先遍历写缓冲区，若未命中再从Flash中读取。实现上，本周只进行小部分的代码修改，准备下一周完成关于设置写缓冲区相关的代码修改。

<font size=6>202303023
-------
上周忘了更新文档，这两周主要阅读FEMU代码，目前找到了FEMU的两个线程（数据存储和数据管理）之间的同步，目前正在测试部数据压缩部分，但因为不熟悉工具使用目前还在学习。下一步准备验证FEMU两个存储和管理两个线程的同步关系，进而实现管理的数据代码部分。

<font size=6>202303023
-------
本周周一确诊甲流，本周大部分时间都在休息。不过这周学会了对项目的调试以及找到了项目中数据存储和管理两个部分同步的函数，并且进行了验证。接下来准备开展对于项目中数据管理部分相关的代码实现。

<font size=6>20230407
-------
本周继续了上周的工作，对FEMU中数据管理部分进行开发，目前正在实现设置缓冲区并实现分类的部分。同时还阅读了下周要分享的FAST论文，并且制作了PPT准备下一周分享。下一周继续工程上的推进。

<font size=6>20230414
-------
本周主要是进行数据布局函数的编写（正在实现re-bp方案），主要包括ssd_write函数和ssd_read函数，即修改ftl来进行数据布局的控制。遇到的问题包括（1）如何将页中的每一个压缩页取出来按照大小进行排序。（2）如何对压缩页进行失效标记，进而实现页失效的标记。ssd内压缩将失效数据的粒度从一个4kb的页降到一个压缩后的数据页。（3）gc时需要迁移有效的数据页到新的块。因此我在实现过程中引进一个反向映射的数据结构来实现ppn->lpn的1：n映射，即根据一个ppn可以获取里面的所有lpn（lpn通常为多个，一个物理页含有多个压缩页）。因为我们需要对压缩页按照大小进行排序，所以需要记录每一个物理页里面的压缩页的数据块，而数据块使用lpn来进行唯一标识（页级映射）。而且此前没有考虑到gc部分，gc过程需要将有效的压缩块迁移到空闲的压缩块，因此不仅要有ppn->lpn的1：n映射，还需要有一个valid标识位来记录哪一个压缩页是有效的，并且还需要将有效的压缩页拼接起来。目前正在进行这部分的代码编写，以及在编写过程中发现并解决问题。下一周继续进行代码编写，打算下一周可以完成代码编写以及进行正确性的验证和进行性能测试。